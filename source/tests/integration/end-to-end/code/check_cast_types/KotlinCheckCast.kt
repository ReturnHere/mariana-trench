/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.marianatrench.integrationtests

/**
 * Mirrors JavaCheckCast.java to show the differences between Java and Kotlin byte code where the
 * check-cast instruction is concerned. When casting from derived to base, Kotlin's generated byte
 * code contains the check-cast instruction.
 */
public class KotlinCheckCast {

  public open class Base {
    public open fun run(argument: Object) = Unit
  }

  public class DerivedWithSink : Base() {
    public override fun run(argument: Object) {
      Origin.sink(argument)
    }
  }

  public class DerivedNoSink : Base() {
    public override fun run(argument: Object) = Unit
  }

  // User-defined shim to call klass.run(argument)
  public fun shimmed(klass: Base, argument: Object) = Unit

  public fun issueFromCheckCastType() {
    // There is a check-cast instruction (DerivedWithSink to Base) in the byte
    // code. The corresponding register type is Base. Analysis will consider
    // all derived classes, hence this source is seen to flow into a sink.
    shimmed(DerivedWithSink(), Origin.source() as Object)
  }

  public fun falsePositiveFromCheckCastType() {
    // False positive because of check-cast instruction (see
    // `issueFromCheckCastType`).
    shimmed(DerivedNoSink(), Origin.source() as Object)
  }

  public fun issueFromVirtualBaseType() {
    var base: Base? = null

    // Each block has a check-cast from Derived -> Base
    if ((0..1).random() > 0) {
      base = DerivedWithSink()
    } else {
      base = DerivedNoSink()
    }

    // No check-cast instruction here (type of `base` is already Base).
    shimmed(base, Origin.source() as Object)
  }

  public fun issueFromCheckCastType2(base: Base) {
    val derived = base as DerivedWithSink
    shimmed(derived, Origin.source() as Object)
  }

  public fun falsePositiveFromCheckCastType2(base: Base) {
    // Ideally, the type should be handled as DerivedNoSink. There is a
    // check-cast instruction for it. However, another check-cast (to Base)
    // instruction is introduced when calling shimmed(derived, ...).
    val derived = base as DerivedNoSink
    shimmed(derived, Origin.source() as Object)
  }
}
